// BEGIN export
export const prefixes = [
    "anti",
    "auto",
    "de",
    "dis",
    "down",
    "extra",
    "hyper",
    "il",
    "im",
    "inter",
    "ir",
    "mega",
    "mid",
    "mis",
    "non",
    "out",
    "over",
    "post",
    "pre",
    "pro",
    "re",
    "semi",
    "sub",
    "super",
    "trans",
    "ultra",
    "un",
    "under",
    "up",
];
export const words = [
    "appear",
    "award",
    "bauble",
    "bubble",
    "butterfly",
    "cable",
    "cafe",
    "cafeteria",
    "car",
    "clay",
    "combine",
    "commerce",
    "concrete",
    "confession",
    "construct",
    "contact",
    "convertible",
    "credit",
    "echo",
    "edit",
    "entertained",
    "entrance",
    "equip",
    "established",
    "experts",
    "farewell",
    "fastidious",
    "food",
    "gecko",
    "giraffe",
    "growth",
    "hippo",
    "integrity",
    "juice",
    "lake",
    "lift",
    "magazine",
    "mars",
    "mild",
    "monkey",
    "mood",
    "motif",
    "mummy",
    "news",
    "offer",
    "oven",
    "paper",
    "pile",
    "planet",
    "planet",
    "platter",
    "pond",
    "popsicle",
    "possible",
    "power",
    "print",
    "quarter",
    "queso",
    "root",
    "sea",
    "shock",
    "sniff",
    "spirit",
    "stack",
    "star",
    "sustain",
    "syrup",
    "taste",
    "television",
    "terrace",
    "threshold",
    "topic",
    "trail",
    "trip",
    "vegetarian",
];
export const suffixes = [
    "age",
    "al",
    "dom",
    "ee",
    "ence",
    "hood",
    "ism",
    "ist",
    "ment",
    "ness",
    "or",
    "ry",
    "ship",
    "tion",
];
export const titles = [
    "DSA",
    "XPS",
    "CSAT",
    "APEX",
    "Vostro",
    "Latitude",
    "Optiplex",
    "Inspiron",
    "G Series",
    "Alienware",
    "Precision",
    "Ultrasharp",
    "Deployment",
    "Consulting",
    "Chromebooks",
    "Dell Outlet",
    "Laptop Deals",
    "Small Business",
    "Dell Education",
    "Latitude Rugged",
    "Global Wellness",
    "Support Services",
    "Managed Services",
    "Services for Home",
    "Education Services",
    "Dell Design System",
    "Dell Chrome Enterprise",
    "G Series Gaming Laptops",
    "Foundations & Components",
    "Medium & Large Organizations",
    "Incident Response and Recovery",
];
export const names = [
    {
        first: "Dipper",
        last: "Pines",
    },
    {
        first: "Mabel",
        last: "Pines",
    },
    {
        first: "Stan",
        last: "Pines",
    },
    {
        first: "Ford",
        last: "Pines",
    },
    {
        first: "Wendy",
        last: "Corduroy",
    },
    {
        first: "Soos",
        last: "Ramirez",
    },
    {
        first: "Robbie",
        last: "Valentino",
    },
    {
        first: "Pacifica",
        last: "Northwest",
    },
    {
        first: "Gideon",
        last: "Gleeful",
    },
    {
        first: "Bill",
        last: "Cipher",
    },
    {
        first: "Fiddleford",
        last: "McGucket",
    },
    {
        first: "Candy",
        last: "Chiu",
    },
    {
        first: "Grenda",
        last: "Grendinator",
    },
    {
        first: "Bud",
        last: "Gleeful",
    },
    {
        first: "Sheriff",
        last: "Blubs",
    },
    {
        first: "Deputy",
        last: "Durland",
    },
    {
        first: "Toby",
        last: "Determined",
    },
    {
        first: "Quentin",
        last: "Trembley",
    },
    {
        first: "Tyler",
        last: "Cutebiker",
    },
    {
        first: "Blendin",
        last: "Blandin",
    },
    {
        first: "Lazy",
        last: "Susan",
    },
    {
        first: "Manly",
        last: "Dan",
    },
    {
        first: "Preston",
        last: "Northwest",
    },
    {
        first: "Priscilla",
        last: "Northwest",
    },
    {
        first: "Hank",
        last: "Northwest",
    },
    {
        first: "Shandra",
        last: "Jimenez",
    },
    {
        first: "Tad",
        last: "Strange",
    },
    {
        first: "Mr",
        last: "s. Gleeful",
    },
    {
        first: "Lee",
        last: "Northwest",
    },
    {
        first: "Nate",
        last: "Northwest",
    },
    {
        first: "Abuelita",
        last: "Ramirez",
    },
    {
        first: "Agent",
        last: "Powers",
    },
    {
        first: "Agent",
        last: "Trigger",
    },
    {
        first: "Old",
        last: "Man McGucket",
    },
    {
        first: "Rumble",
        last: "McSkirmish",
    },
    {
        first: "Summerween",
        last: "Trickster",
    },
    {
        first: "Time",
        last: "Baby",
    },
    {
        first: "Lolph",
        last: "and Dundgren",
    },
    {
        first: "Se",
        last: "v'ral Timez",
    },
    {
        first: "Mermando",
        last: "Merman",
    },
    {
        first: "Love",
        last: "God",
    },
    {
        first: "Pa",
        last: "Duskerton",
    },
    {
        first: "Blind",
        last: "Ivan",
    },
];
export const timespans = [
    "milliseconds",
    "seconds",
    "minutes",
    "hours",
    "days",
    "weeks",
    "fortnights",
    "months",
    "years",
    "decades",
    "generations",
    "millenia",
];
export const quotes = {
    gravityfalls: [
        "Get 'em! Get 'em!",
        "Emergency salami?",
        "Is life just some horrific joke, without a punch line? That we're all just biding our time until the sweet, sweet release of death?",
        "Finally, a good reason to punch a teenager in the face!",
        "Songs are like hugs that mouths give to ears!",
        "It all begins with this little fella, the pituitary gland. He may be little, but he has *big plans.*",
        "Shhh, you've had me a 'shut up, old man.'",
        "Why do you have forks taped to your fingers?",
        "Remember: reality is an illusion. The universe is a hologram. Buy gold. Bye!",
        "Lick that elbow! Lick that elbow!",
        "Like the infinite horizon, it eludes my grasp.",
        "A frog taught me how to cross the street [points to 'Frogtime' game].", 
        "When my house was haunted I learned how to eat ghosts [gestures to 'ghost maze' game].", 
        "And this thing taught me how to dance [gestures to 'Ho-Down Hero' game] .",
        "Winners don't lose!",
        "The secret ingredient to my coffee omelette, is coffee.",
        "I can verify that that birth mark is indeed disgusting.",
        "The Mystery Shack is back, baby!",
        "I'm legalizing everything!",
        "Just ten minutes, without this pig in the house. Is that so much to ask?",
        "Oooooooohhh! Old people movies! Get ready for references we won't understand and words we can't repeat.",
        "Exodus demonus, spookus-scareus. Ain'tafraidus Noghostus.",
        "[screams] Braces! Braces caught in the screen door! Someone dictate my will! I'm giving it all to Waddles!",
        "[gasps] A woman! All right, Soos, you can do this. Just use your mouth to say words that make romance happen. Your face is good! I'm a Soos!",
        "You're watching the Black and White Period Piece Old Lady Boring Movie Channel.", 
        "Stay tuned for the Friday night movie 'The Duchess Approves,' starring Sturly Stembleburgiss as 'The Duchess'",
        "The future, is in the past. ONWARDS AOSHIMA!",
        "Today, I learned that morality is relative!",
        "All right, maybe I haven't been the best summer caretaker. But I swear, today we're gonna have some real family fun. Now who wants to put on some blindfolds and get into my car?",
        "Dude, am I a side character? Do you ever think about stuff like that?",
        "Wanna hear a joke? Here goes: my ex-wife still misses me *but her aim is getting better!* *Her aim is getting better!* You see, it's funny because marriage is terrible!",
        "When there's no cops around, anything's legal!",
        "I just wish summer could never end",
        "Shmebulock!",
        "My wisdom is both a blessing and a curse.",
        "Uhh, do you like me? Yes, definitely, absolutely?", 
        "And here we have 'Rock That Looks Like a Face Rock'; the rock that looks like a face.", 
        "Oh, hey there. You know, this is all really just a big misunderstanding. You see, your sister's not in any danger. She's just marrying all 1,000 of us and becoming our gnome queen for all eternity. Isn't that right, honey?", 
        "You guys are butt-faces!", 
        "It's Family Fun Day, genius! We're cuttin' off work and having one of those, you know, bonding-type deals.", 
        "Sweet! Beaver with a chainsaw!", 
        "Why did the Pel-ican get kicked out of the res-taurant? Cuz he had a very BIG BILL!!! La-la-la-la Yuk-yuk-yuk!", 
        "For tonight's final illusion, we have the incredible Sack of Mystery. When you put your money in, it mysteriously disappears!", 
        "I was hanging out with my new pal Gideon. He is one dapper little man!", 
        "Hey, dude! You ready to blow up these hot dogs in the microwave, one by one?", 
        "I wonder what the new name will be for the power couple. Mab-ideon? Gide-Abel? [Gasps] Ma-gid-bel-eon!", 
        "Your sister seems to be going nuts with that Smile Dip.", 
        "But before you leave, hot dogs are now half off. I know it might be crazy, but you gotta try these dogs!", 
        "Back when we were alive, teenagers were a scourge on our store! Always sassafrassing customers with their boomy-boxes and disrespectful short pants! So we decided to up and ban them. But they retaliated with their newfangled rap music.", 
        "Homework's whack, and so are rules! Tucking in your shirt's for fools!", 
        "I think I'll go stare at a wall for a while and RETHINK EVERYTHING. Hey, next time we hang out, let's stay at the Mystery Shack. Okay?", 
        "Thanks there, sugar pot. I-I mean honey wasp, kitten baby, b-baby cow.", 
        "Grunkle Stan, you are a cranky, gross, weird old man. But we're gonna get Lazy Susan to like you because nothing is stronger than the power of... Mabel!", 
        "Well, hornswaggle my haversack!", 
        "There's a carpetbagger in the turnip cellar!", 
        "If you're watching this, you are one of eight people in these United States with clearance to view this information. In fact, I myself will be shot once the filming is complete.", 
        "You're under arrest for violation of the Time Traveler's Code of Conduct.", 
        "You know, studies show that keeping a ladder inside the house is more dangerous than a loaded gun. That's why I own ten guns, in case some maniac tries to sneak in with a ladder.", 
        "why you ackin' so cray-cray?", 
        "I am ready to take on the greatest Fight Fighters! Take me to the Soviet Union!", 
        "What's going on out here, dudes? I heard a ruckus. Heh-heh, that's a funny word. 'Ruckus'.", 
        "You know, kids? I've been thinkin'. At the end of the day, Summerween isn't about candy or costumes, or even scaring people. It's a day when the whole family can get together at one place and celebrate what really matters... PURE EVIL!!", 
        "Grunkle Stan, whatever happened to please and thank you? Hmmm. Oh wait here they are.", 
        "Oh! Who's that? Is it Questiony The Question Mark?", 
        "Anything is possible when you...IMAGINIZE it!!", 
        "I'm Stan, and I was wrong. I'm singing the Stan Wrong Song. I shouldn't have taken that chance. Now here's my remorseful dance.", 
        "Am I a man? Am I a baby? These are legitimate questions.", 
        "Yeah, nothing like sitting in a moist tub with strangers. It's like the bus but wet.", 
        "I am the lifeguard. I make the rules, sucka! Boosh!", 
        "The inflatable pool duck revolution is at hand...", 
        "Okay, my original plan was to tape together a bunch of fish sticks to make prosthetic pair of people legs.", 
        "Get ready to be poked by the fun stick! Boop!", 
        "Oh Oh! Girl you got me actin' so Cray Cray! (Cray-Cray!) You say you won't be my baaa-bay! We're not threatening!", 
        "How many times am I gonna love ya? SEV'RAL TIMEZ!", 
        "Hey Girl, I just wanna get real for a moment and say that while we love being superstars, the real reason we do this... is for you. For you specifically, not the girl sitting next to you, but YOU.", 
        "Ohh! Who goes there? Prepare to be danced at!", 
        "Step off Deep Chris! She's a lady! Don't disrespect her bro! Don't disrespect!!", 
        "Chubby Z let's calm this boo by posin' for her, poster-style.", 
        "Yo, I heard about these things called trees...I don't know what they are, but I wanna kiss one!",         
    ],
}
/**
 * Sorts an array of objects by value of a property on the objects
 * @param {string} propToSort - the name of the property on which to sort
 * @param {array} arrToSort - the array of objects to sort
 * @return {array} the sorted array
 */
export const sortArrayOfObjects = (propToSort, arrToSort, direction = "asc") => {
    const sortOrder = direction === "asc" ? 1 : -1;
    return arrToSort.sort((a, b) => {
        const result = a[propToSort] < b[propToSort] ? -1 : a[propToSort] > b[propToSort] ? 1 : 0;
        return result * sortOrder;
    });
};

const range = (seed, modulo) => {
    return (
        `${((2 ** 31 - 1) & Math.imul(48271, seed)) / 2 ** 31}`.split("").slice(-10).join("") %
        modulo
    );
};
export const unique = function (custom) {
    const type = !custom
    ? undefined
    : typeof custom === "string"
    ? "string"
    : typeof custom === "number"
    ? "number"
    : "array";

    const crypto = window.crypto || window.msCrypto; // Math.random is forbidden by Checkmarx
    const crpValue = crypto.getRandomValues(new Uint32Array(10))[0];
    let min;
    let max;
    switch (type) {
        case "string":
            return `${custom}_${crpValue}`;
        case "number":
            return range(crpValue, custom);
        case "array":
            min = typeof custom[0] === "string" ? Number(custom[0]) : custom[0];
            max = typeof custom[1] === "string" ? Number(custom[1]) : custom[1];
            return range(crpValue, max - (min - 1)) + min;
        default:
            return crpValue;
    }
};
const randomDate = (
    start = new Date(`${unique([1850, 2023])}/${unique([1, 12])}/${unique([1, 28])}`),
    end,
    startHour,
    endHour
) => {
    if (!end) {
        const nextDay = new Date(start);
        nextDay.setDate(nextDay.getDate() + 30);
        end = nextDay;
    }
    if (!startHour) {
        startHour = 0;
    }
    if (!endHour) {
        endHour = 23;
    }

    var date = new Date(+start + Number(`0.${unique()}`) * (end - start));
    var hour = (startHour + Number(`0.${unique()}`) * (endHour - startHour)) | 0;
    date.setHours(hour);
    return date;
};
export const make = {
    email: (options = {}) => {
        const fName = options.first || make.name("first");
        const lName = options.last || make.name("last");
        const name = {
            first: fName,
            last: lName,
        };
        const domain = make.word(true, true);
        const ext = make.choice.exact([`com`, `net`, `org`, `ai`, `app`, `cloud`]);
        return `${name.first}_${name.last}@${domain}.${ext}`;
    },
    choice: {
        exact: (choices) => {
            if (!choices) return "";
            if (typeof choices === "string") choices = choices.split(",");
            const selection = make.number(0, choices.length - 1);
            return choices[selection];
        },
    },
    color: (cOptions) => {
        let hue;
        const low =make.number(0, 192);
        const high = make.number(192, 255);
        // Generate random values for two of RGB options, keeping them on the lower side
        // Keep the primary component at or near its maximum to ensure hue
        switch (cOptions) {
            case "yellow":
                hue = "red green";
                break;
            case "purple":
                hue = "red blue";
                break;
            default:
                hue = cOptions;
                break;
        }
        let red = hue?.indexOf("red") > -1 ? high : low;
        let green = hue?.indexOf("green") > -1 ? high : low;
        let blue = hue?.indexOf("blue") > -1 ? high : low;

        // Convert each component to a hex string and concatenate them
        return '#' + red.toString(16).padStart(2, '0') + green.toString(16).padStart(2, '0') + blue.toString(16).padStart(2, '0');
    },
    custom: {
        value: (entry) => {
            return entry;
        },
    },
    date: {
        format: (type, min, max) => {
            if (Number(type)) {
                max = min;
                min = type;
                type = undefined;
            } else if (type && type.match(/\//g)) {
                max = min;
                min = type;
                if (type.indexOf("/") === type.lastIndexOf("/")) {
                    type = `${new Date().getFullYear()}/${type}`;
                }
                if (min.indexOf("/") === min.lastIndexOf("/")) {
                    min = `${new Date().getFullYear()}/${min}`;
                }
                if (max.indexOf("/") === max.lastIndexOf("/")) {
                    max = `${new Date().getFullYear()}/${max}`;
                }
                const fullYear = type.substr(type.lastIndexOf("/"), type.length-1 - type.lastIndexOf("/")).length === 4;
                const yearFirst = type.substr(0, type.indexOf("/")).length === 4;
                if (fullYear) {
                    type = "mm/dd/yyyy";
                } else if (yearFirst) {
                    type = "yyyy/mm/dd";
                } else {
                    type = "mm/dd/yy";
                }
            }

            if (type) type = type.toLowerCase();
            if (min) min = new Date(min);
            if (max) max = new Date(max);
            if (!max && min) max = new Date(min);

            const newDate = randomDate(min, max);

            const hours = newDate.getHours();
            const ap = hours < 12 ? `AM` : `PM`;
            const yr = newDate.getFullYear().toString();
            let mo = `0${newDate.getMonth()+1}`;
            let da = `0${newDate.getDate()}`;
            let hr = `0${ap === `AM` ? hours : hours - 12}`;
            let mi = `0${newDate.getMinutes()}`;
            let se = `0${newDate.getSeconds()}`;
            if (hr === `00`) hr = `12`;
            if (mo.length > 2) mo = mo.substr(1, 2);
            if (da.length > 2) da = da.substr(1, 2);
            if (hr.length > 2) hr = hr.substr(1, 2);
            if (mi.length > 2) mi = mi.substr(1, 2);
            if (se.length > 2) se = se.substr(1, 2);

            switch (type) {
                case "yy":
                    return yr.substr(2,2);
                case "year":
                case "yyyy":
                    return yr;
                case "us":
                case "mm/dd/yyyy":
                    return `${mo}/${da}/${yr}`;
                case "mm/dd/yy":
                    return `${mo}/${da}/${yr.substr(2,2)}`;
                case "short":
                    return `${mo.replace(/0/, "")}/${da.replace(/0/, "")}/${yr.substr(2,2)}`;
                case "mi":
                case "minutes":
                    return mi;
                case "hr":
                case "hours":
                    return hr;
                case "se":
                case "sec":
                case "seconds":
                    return se;
                case "verbose":
                    return `${yr}/${mo}/${da} ${hr}:${mi}:${se} ${ap}`;
                case "obj":
                    return newDate;
                default:
                    return `${yr}/${mo}/${da}`;
            }
        },
    },
    /**
     * Creates a gibberish word with a given number of syllables, each 3 characters long
     * @param {number} syllableCount - the number of syllables to add to the new word
     * @return {string} the newly-invented word
     */
    gibberish: (syllableCount = unique([2, 5])) => {
        const syllables = [
            "ala",
            "boo",
            "car",
            "del",
            "ell",
            "fla",
            "gru",
            "hit",
            "ill",
            "jun",
            "klo",
            "len",
            "min",
            "nub",
            "oon",
            "pew",
            "que",
            "rif",
            "sop",
            "tun",
            "una",
            "vix",
            "wee",
            "yun",
            "zed",
        ];
        const newWord = [];
        for (let intI = 0; intI < syllableCount; intI++) {
            const newSyllable = syllables[make.number(0, syllables.length)];
            newWord.push(newSyllable);
        }
        return newWord.join("");
    },
    id: (id = "id") => {
        if (typeof id === "number") {
            id = `id_${id}`;
        } else if (id === "") {
            id = "id";
        }
        return unique(id).trim();
    },
    name: (type) => {
        // Select a random entry from the names array
        const randomEntry = names[make.number(0, names.length-1)];

        switch (type) {
            case 'first':
                return randomEntry.first;
            case 'last':
                return randomEntry.last;
            case 'full':
                return `${randomEntry.first} ${randomEntry.last}`;
            default:
                return {
                    first: randomEntry.first,
                    last: randomEntry.last,
                };
        }
    },
    number: (min, max) => unique([min, max]),
    /**
     * Creates a random-length phrase with newly-generated words
     * @param {number} wordCount - the number of words to add to the new phrase
     * @return {string} the newly-invented phrase
     */
    phrase: (wordCount = unique([2, 4])) => {
        const newPhrase = [];
        for (let intI = 0; intI < wordCount; intI++) {
            const newWord = make.word();
            if (newWord.length > 0) {
                newPhrase.push(newWord);
            }
        }
        return newPhrase.join(" ");//
    },
    quote: (options = {}) => {
        if (typeof options === `number`) {
            options = { paragraphs: options };
        } else if (typeof options === `string`) {
            options = {
                type: options, // use later
                paragraphs: 1,
            }
        }
        const optParas = options.paragraphs || 1;
        const optType = options.type || `gravityfalls`;
        const optSentences = options.sentences || 3;

        let quote = ``;
        for (let i = 0; i < optParas; i++) {
            if (optParas > 1) quote += `<p>`;
            for (let j = 0; j < (optSentences || make.number(4,7)); j++) {
                const randomQuote = make.number(0, quotes[optType].length-1);
                quote += `${quotes[optType][randomQuote]} `;
            }
        }
        return quote;
    },
    timespan: () => {
        const randomTimespan = make.number(0, timespans.length-1);
        return timespans[randomTimespan];
    },
    title: () => {
        const randomTitle = make.number(0, titles.length-1);
        return titles[randomTitle];
    },
    /**
     * Creates a random word that is nearly like an English word
     * @param {boolean} prefix - whether or not to add a prefix
     * @param {boolean} suffix - whether or not to add a suffix
     * @return {string} the newly-invented word
     */
    word: (prefix = false, suffix = false) => {
        const myWord = [];
        if (prefix) {
            myWord.push(prefixes[make.number(0, prefixes.length - 1)]);
        }

        myWord.push(words[make.number(0, words.length - 1)]);

        if (suffix) {
            myWord.push(suffixes[make.number(0, suffixes.length - 1)]);
        }

        return myWord.join("").replace("ttion", "tion");
    },
};
const getMakeCommand = (stringifiedCommand) => {
    const instr = stringifiedCommand.split(".");
    const makeProperties = Object.keys(make);
    if (!makeProperties.includes(instr[0])) {
        return stringifiedCommand;
    }
    let makeCmd = make[instr[0]];
    let intI = 1;
    do {
        if (makeCmd[instr[intI]]) {
            makeCmd = makeCmd[instr[intI]];
        }
        intI++;
    } while (makeCmd[instr[intI]] != null);
    const leftovers = [];
    for (let intL = intI; intL < instr.length; intL++) {
        leftovers.push(instr[intL]);
    }
    return makeCmd(...leftovers);
};
/**
 * Generates an array of data based on "blueprint" strings
 * @summary Each blueprint string represents a series of parameters on the Make object
 *          followed by a series of parameters to be sent to the method that is found on the Make object
 *          Note that there must be at least two levels of methods sent; if Make only needs one to find
 *          the intended method and you want to also send parameters to that method, then just send
 *          anything for the second method level.  For example:
 *          getMakeCommand("id.IWantToSendAParameter.myCustomIdPrefix")
 * @param {number} bpCount - how many rows of data to generate
 * @param {array} blueprint - An array of strings with dot-separated methods and parameters
 * @return {array} the generated array
 */
export const generateData = (bpCount, blueprint) => {
    const bp = [];
    const bpBlueprint = {};
    const bpKeys = [];
    blueprint.forEach(bpInstruction => {
        let tries = 0;
        let suggestedKey = getMakeCommand(bpInstruction[0]);
        const currentKeyValues = [];
        Object.keys(bpKeys).forEach((arrKey) => {
            currentKeyValues.push(bpKeys[arrKey]);
        });
        while (tries < 42 && currentKeyValues.includes(suggestedKey)) {
            suggestedKey = getMakeCommand(bpInstruction[0]);
            tries++;
        }
        bpKeys.push(suggestedKey);
    });
    blueprint.forEach((bpInstruction, bpIndex) => {
        bpBlueprint[bpKeys[bpIndex]] = bpInstruction[1];
    });
    for (let intD = 0; intD < bpCount; intD++) {
        const arr = {};
        Object.keys(bpBlueprint).forEach((key) => {
            let tries = 0;
            let suggestedValue = getMakeCommand(bpBlueprint[key]);
            const previousKeyValues = bp.map((a) => a[key]);
            const currentKeyValues = [];
            Object.keys(arr).forEach((arrKey) => {
                currentKeyValues.push(arr[arrKey]);
            });
            while (
                tries < 42 &&
                (currentKeyValues.includes(suggestedValue) ||
                 previousKeyValues.includes(suggestedValue))
            ) {
                suggestedValue = getMakeCommand(bpBlueprint[key]);
                tries++;
            }
            arr[key] = suggestedValue;
        });
        bp.push(arr);
    }
    return bp;
};
// END export
